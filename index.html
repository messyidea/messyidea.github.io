
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Messyidea&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="messy ideas">
<meta property="og:type" content="website">
<meta property="og:title" content="Messyidea&#39;s blog">
<meta property="og:url" content="http://messyidea.com/index.html">
<meta property="og:site_name" content="Messyidea&#39;s blog">
<meta property="og:description" content="messy ideas">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Messyidea&#39;s blog">
<meta name="twitter:description" content="messy ideas">
  
    <link rel="alternative" href="/atom.xml" title="Messyidea&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Messyidea&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/Projects">Projects</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="messyidea.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main">
  
    <article id="post-Hasee-Z7-sl7d3-archlinux-安装教程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/03/Hasee-Z7-sl7d3-archlinux-安装教程/" class="article-date">
  <time datetime="2017-03-04T00:11:00.000Z" itemprop="datePublished">3月 3 2017</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Notes/">Notes</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/03/Hasee-Z7-sl7d3-archlinux-安装教程/">Hasee Z7 sl7d3 archlinux 安装笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本来以为很简单的，没想到踩了这么多坑。花了好几天时间才装好。<br>如果有外置显示器的需求的话，建议不要碰 gnome3 和 wayland<br>因为这台笔记本的 hdmi 口和 mini dp 口直连独显，如果需要双显卡工作的话必须使用 intel-virtual-output ， intel-virtual-output 这个东西貌似不支持 wayland， 总是检测不到 virtual display （wayland 从只差一步到放弃 = =）。<br>基于 Xorg 的 gnome3 对 intel-virtual-output 支持完好， 不过不知道什么原因， 在连接外置显示器的情况下， 合上盖子或者是只用外置显示器会导致蜜汁卡吨，花大量时间搜寻后无解（起初以为是acpi的问题，不过内核加参数 acpi=off 会导致笔记本开不了机）。经测试，Xfce4 正常， 所以之后选择了 Xfce4。</p>
<h2 id="为了避免以后踩坑，下面记录下步骤。"><a href="#为了避免以后踩坑，下面记录下步骤。" class="headerlink" title="为了避免以后踩坑，下面记录下步骤。"></a>为了避免以后踩坑，下面记录下步骤。</h2><p>1 制作 Arch 启动u盘<br>2 在BIOS下把显卡模式切换为 <code>DISCRETE</code> （BIOS 对于显卡有两个模式，分别是MSHYBRID 和 DISCRETE, MSHYBRID是双显卡切换， DISCRETE是只用独显，MSHYBRID模式不能够启动 Arch U盘 ）<br>3 启动 Arch 安装盘<br>4 fdisk 分区<br>5  挂载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># /dev/sdb2 是 / ， /dev/sdb1 是boot, /dev/sdb3 是 /home</div><div class="line"># 具体按照自己的分区来</div><div class="line">mount /dev/sdb2 /mnt</div><div class="line">mkdir /mnt/boot</div><div class="line">mkdir /mnt/home</div><div class="line">mount /dev/sdb1 /mnt/boot</div><div class="line">mount /dev/sdb3 /mnt/home</div></pre></td></tr></table></figure></p>
<p>6  更新mirrors<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cd /etc/pacman.d </div><div class="line">sed -i &quot;s/^\b/#/g&quot; mirrorlist </div><div class="line">nano mirrorlist </div><div class="line">#将mirrors.ustc.edu.cn和mirrors6.ustc.edu.cn前面的#去掉 </div><div class="line">pacman -Syy</div></pre></td></tr></table></figure></p>
<p>7 安装base系统<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pacstrap /mnt base base-devel </div><div class="line">#如果你想使用ifconfig之类的工具，请在上面加上net-tools</div></pre></td></tr></table></figure></p>
<p>8 生成fstab<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">genfstab -U -p /mnt &gt;&gt;/mnt/etc/fstab</div></pre></td></tr></table></figure></p>
<p>9 chroot<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arch-chroot /mnt /bin/bash</div></pre></td></tr></table></figure></p>
<p>10 配置locale<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cd /etc</div><div class="line">nano locale.gen</div><div class="line">#将en_US.UTF-8,zh_CN.GBK,zh_CN.GB2312,zh_CN.GB18030,zh_CN.UTF-8前的#去掉 </div><div class="line">locale-gen </div><div class="line">echo LANG=zh_CN.UTF-8 &gt;&gt; locale.conf</div></pre></td></tr></table></figure></p>
<p>11 设置时区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</div></pre></td></tr></table></figure></p>
<p>12 设置主机名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo 主机名 &gt;&gt; /etc/hostname</div></pre></td></tr></table></figure></p>
<p>13 用户配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">passwd </div><div class="line">#修改root密码 </div><div class="line">useradd -m -g users -G wheel -s /bin/bash 用户名 </div><div class="line">passwd 用户名</div></pre></td></tr></table></figure></p>
<p>14 安装GRUB<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 具体硬盘要根据自己的来</div><div class="line">pacman -S grub-bios </div><div class="line">grub-install /dev/sdb</div></pre></td></tr></table></figure></p>
<p>开机需要内核开启一些参数（如果不加这些参数之后的bbswitch工作会不正常， 见<a href="https://github.com/Bumblebee-Project/Bumblebee/issues/764#issuecomment-234494238" target="_blank" rel="external">这里</a>）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">vim /etc/default/grub</div><div class="line"># 配置 GRUB_CMDLINE_LINUX_DEFAULT</div><div class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet acpi_osi=! acpi_osi=\&quot;Windows 2009\&quot;&quot;</div><div class="line"></div><div class="line"># 之后生成grub.cfg</div><div class="line">grub-mkconfig -o /boot/grub/grub.cfg</div><div class="line"></div><div class="line"># 开启dhcpcd</div><div class="line">systemctl enable dhcpcd.service</div></pre></td></tr></table></figure></p>
<p>15 退出chroot， 重启<br>16 安装synaptics驱动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pacman -S xf86-input-synaptics</div></pre></td></tr></table></figure></p>
<p>17 安装 xorg<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pacman -S xorg-server xorg-xinit xorg-utils xorg-server-utils</div></pre></td></tr></table></figure></p>
<p>18 安装xfce4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pacman -S xfce4 xfce4-goodies</div><div class="line"># 如果需要从命令行启动xfce的话只需要进行如下步骤</div><div class="line">cp /etc/X11/xinit/xinitrc ~/.xinitrc</div><div class="line"># 在.xinitrc后加上 exec startxfce4 即可</div></pre></td></tr></table></figure></p>
<p>19 配置双显卡<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">pacman -S bumblebee</div><div class="line">pacman -S mesa</div><div class="line">pacman -S xf86-video-intel</div><div class="line">pacman -S nvidia</div><div class="line">gpasswd -a 用户名 bumblebee</div><div class="line">systemctl enable bumblebeed.service</div></pre></td></tr></table></figure></p>
<p>在 /etc/X11/xorg.conf.d下创建一个文件 <code>20-intel.conf</code>， 内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Section &quot;Device&quot;</div><div class="line">        Identifier &quot;Intel Graphics&quot;</div><div class="line">        Driver     &quot;intel&quot;</div><div class="line">        BusID      &quot;PCI:00:02:0&quot;    # &lt;&lt;&lt;&lt; replace with correct address</div><div class="line">EndSection</div></pre></td></tr></table></figure></p>
<p>配置 /etc/bumblebee/xorg.conf.nvidia<br>内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">Section &quot;ServerLayout&quot;</div><div class="line">    Identifier  &quot;Layout0&quot;</div><div class="line">    Option      &quot;AutoAddDevices&quot; &quot;true&quot;</div><div class="line">    Option      &quot;AutoAddGPU&quot; &quot;false&quot;</div><div class="line">EndSection</div><div class="line"></div><div class="line">Section &quot;Device&quot;</div><div class="line">    Identifier  &quot;DiscreteNvidia&quot;</div><div class="line">    Driver      &quot;nvidia&quot;</div><div class="line">    VendorName  &quot;NVIDIA Corporation&quot;</div><div class="line"></div><div class="line">#   If the X server does not automatically detect your VGA device,</div><div class="line">#   you can manually set it here.</div><div class="line">#   To get the BusID prop, run `lspci | egrep &apos;VGA|3D&apos;` and input the data</div><div class="line">#   as you see in the commented example.</div><div class="line">#   This Setting may be needed in some platforms with more than one</div><div class="line">#   nvidia card, which may confuse the proprietary driver (e.g.,</div><div class="line">#   trying to take ownership of the wrong device). Also needed on Ubuntu 13.04.</div><div class="line">    BusID &quot;PCI:01:00:0&quot;</div><div class="line"></div><div class="line">#   Setting ProbeAllGpus to false prevents the new proprietary driver</div><div class="line">#   instance spawned to try to control the integrated graphics card,</div><div class="line">#   which is already being managed outside bumblebee.</div><div class="line">#   This option doesn&apos;t hurt and it is required on platforms running</div><div class="line">#   more than one nvidia graphics card with the proprietary driver.</div><div class="line">#   (E.g. Macbook Pro pre-2010 with nVidia 9400M + 9600M GT).</div><div class="line">#   If this option is not set, the new Xorg may blacken the screen and</div><div class="line">#   render it unusable (unless you have some way to run killall Xorg).</div><div class="line">    Option &quot;ProbeAllGpus&quot; &quot;false&quot;</div><div class="line"></div><div class="line">    Option &quot;AllowEmptyInitialConfiguration&quot;</div><div class="line">    Option &quot;NoLogo&quot; &quot;true&quot;</div><div class="line">    Option &quot;UseEDID&quot; &quot;true&quot;</div><div class="line">    # Option &quot;UseDisplayDevice&quot; &quot;none&quot;</div><div class="line">EndSection</div></pre></td></tr></table></figure></p>
<p>具体有哪些地方要改呢？<br>对于一般用户，去掉BusID的注释即可。<br>如果有外界屏幕需求的话， 需要把 <code>UseEDID</code> 和 <code>AutoAddDevices</code> 设置为 <code>true</code>, 然后加上 <code>Option &quot;AllowEmptyInitialConfiguration&quot;</code><br>（这三个操作必不可少，缺了AllowEmptyInitialConfiguration会导致 独显初始化失败）<br>更改之后不能进入X环境（因为系统会使用I卡，但是目前只用独显状态I卡识别不了，导致no screen found）<br>20 安装 lightdm（如果命令行启动可以不做）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pacman -S lightdm</div><div class="line">pacman -S  lightdm-gtk-greeter</div><div class="line">systemctl enable lightdm.service</div></pre></td></tr></table></figure></p>
<p>21 重启，在BIOS中把显卡选项切换为 <code>MSHYBRID</code>（不切换进不了系统）<br>22 输入帐号密码之后可以登录<br>23 安装 libxss（intel-virtual-output 依赖这个）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pacman -S libxss</div></pre></td></tr></table></figure></p>
<p>24 激活外接屏幕<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 先激活下 独显， 如果没有此操作，外屏不能被激活 = = ，如果失败的话可能因为显卡未初始化完全，等几秒再尝试下</div><div class="line">optirun glxspheres64</div><div class="line"># 显示成功之后执行下面的命令，外接屏被正确识别</div><div class="line">intel-virtual-output</div></pre></td></tr></table></figure></p>
<p>25 安装常用软件（从<a href="https://github.com/helmuthdu/aui" target="_blank" rel="external">AUI</a>里面拷贝出来了一些常用的软件，具体根据自己需要装）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">pacman -S bc rsync mlocate bash-completion pkgstats arch-wiki-lite</div><div class="line">pacman -S zip unzip unrar p7zip lzop cpio</div><div class="line">pacman -S avahi nss-mdns</div><div class="line">pacman -S alsa-utils alsa-plugins</div><div class="line">pacman -S pulseaudio pulseaudio-alsa</div><div class="line">pacman -S ntfs-3g dosfstools exfat-utils f2fs-tools fuse fuse-exfat autofs mtpfs</div><div class="line">pacman -S --asdeps --needed cairo fontconfig freetype2</div><div class="line">pacman -S networkmanager dnsmasq network-manager-applet nm-connection-editor</div><div class="line">pacman -S networkmanager-openconnect networkmanager-openvpn networkmanager-pptp networkmanager-vpnc</div><div class="line">system_ctl enable NetworkManager.service</div><div class="line"></div><div class="line"># 时间校准</div><div class="line">pacman -S ntpd</div><div class="line">systemctl enable ntpd</div></pre></td></tr></table></figure></p>
<p>其它输入法之类的就不说了。<br>最好加一下archlinuxcn的源，里面可以直接安装sublime， vscode， wps之类的软件，非常方便。</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://my.oschina.net/codeaxe/blog/127533" target="_blank" rel="external">https://my.oschina.net/codeaxe/blog/127533</a><br><a href="https://bbs.archlinux.org/viewtopic.php?id=169742" target="_blank" rel="external">https://bbs.archlinux.org/viewtopic.php?id=169742</a><br><a href="https://github.com/Bumblebee-Project/Bumblebee/issues/764#issuecomment-234494238" target="_blank" rel="external">https://github.com/Bumblebee-Project/Bumblebee/issues/764#issuecomment-234494238</a><br><a href="https://wiki.archlinux.org/index.php/Clevo_P650RS" target="_blank" rel="external">https://wiki.archlinux.org/index.php/Clevo_P650RS</a><br><a href="https://wiki.archlinux.org/index.php/Kernel_parameters" target="_blank" rel="external">https://wiki.archlinux.org/index.php/Kernel_parameters</a><br><a href="https://wiki.archlinux.org/index.php/Bumblebee" target="_blank" rel="external">https://wiki.archlinux.org/index.php/Bumblebee</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://messyidea.com/2017/03/03/Hasee-Z7-sl7d3-archlinux-安装教程/" data-id="cj4mh0s8n00017351gfxnw76e" class="article-share-link" data-share="baidu" data-title="Hasee Z7 sl7d3 archlinux 安装笔记">分享到</a>
      

      
        <a href="http://messyidea.com/2017/03/03/Hasee-Z7-sl7d3-archlinux-安装教程/#disqus_thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-git-repo-永久删除大文件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/17/git-repo-永久删除大文件/" class="article-date">
  <time datetime="2017-02-18T01:21:00.000Z" itemprop="datePublished">2月 17 2017</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Mess/">Mess</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/17/git-repo-永久删除大文件/">git repo 永久删除大文件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>有时候我们可能会因为.gitignore等原因误添加了一些文件<br>删除之后会因为之前commit过导致占用git仓库的空间, 这样非常浪费,尤其是对于那些自建git且有不好的commit习惯的用户</p>
<p>那怎么删除呢?<br>可以借助git的filter-branch(小心使用,因为操作不当可能导致重要记录丢失)</p>
<ol>
<li>首先查看哪些文件最占用git仓库<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rev-list --objects --all | grep "$(git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -5 | awk '&#123;print$1&#125;')"</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>　　rev-list命令用来列出Git仓库中的提交，我们用它来列出所有提交中涉及的文件名及其ID。 该命令可以指定只显示某个引用（或分支）的上下游的提交。<br>　　–objects：列出该提交涉及的所有文件ID。<br>　　–all：所有分支的提交，相当于指定了位于/refs下的所有引用。<br>　　verify-pack命令用于显示已打包的内容。</p>
</blockquote>
<ol>
<li>删除历史提交文件<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git filter-branch --force --index-filter 'git rm -rf --cached --ignore-unmatch filename' --prune-empty --tag-name-filter cat -- --all</div></pre></td></tr></table></figure>
</li>
</ol>
<p>把filename改成你想删除的即可</p>
<ol>
<li>推送repo<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin master --force</div></pre></td></tr></table></figure>
</li>
</ol>
<p>此时remote repo已经被清理了,但是本地的repo多余的文件还没被清理</p>
<ol>
<li>清理本地repo<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rm -rf .git/refs/original/</div><div class="line">git reflog expire --expire=now --all</div><div class="line">git gc --prune=now</div></pre></td></tr></table></figure>
</li>
</ol>
<p>参考: <a href="http://mt.sohu.com/20161027/n471597187.shtml" target="_blank" rel="external">记一次删除Git记录中的大文件的过程</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://messyidea.com/2017/02/17/git-repo-永久删除大文件/" data-id="cj4mh0s9k00067351b7gah825" class="article-share-link" data-share="baidu" data-title="git repo 永久删除大文件">分享到</a>
      

      
        <a href="http://messyidea.com/2017/02/17/git-repo-永久删除大文件/#disqus_thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/">git</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux-的-ACL" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/29/Linux-的-ACL/" class="article-date">
  <time datetime="2017-01-29T16:59:00.000Z" itemprop="datePublished">1月 29 2017</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Mess/">Mess</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/29/Linux-的-ACL/">Linux 的 ACL</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天在配置 squid 的basic auth的时候遇到了一个问题<br>我把htpasswd生成的密码文件放在了/root/config目录下，然后在认证的时候老是遇到http 407 deny</p>
<p>查看/var/log/squid/cache.log 的时候发现不能够 stat 那个密码文件。</p>
<p>之后把那个密码文件 chmod 成777,发现还是不行<br>最后把那个密码文件放在了 /etc/squid 目录下，终于可以了</p>
<p>搜索了一下，发现linux除了一般的文件权限控制还有acl<br>查看了一下fstab文件，确实已经开启了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/dev/vda1  / ext3 noatime,acl,user_xattr 1 1</div></pre></td></tr></table></figure></p>
<p>我去查看了一下那个密码文件的acl，发现是rwx，好像正常的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">debian:~/config# getfacl pass2</div><div class="line"># file: pass2</div><div class="line"># owner: root</div><div class="line"># group: root</div><div class="line">user::rwx</div><div class="line">group::rwx</div><div class="line">other::rwx</div></pre></td></tr></table></figure></p>
<p>后来才发现，原来是 /root 目录对于非root用户设置成了不可读不可写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">debian:~# getfacl /root</div><div class="line">getfacl: Removing leading &apos;/&apos; from absolute path names</div><div class="line"># file: root</div><div class="line"># owner: root</div><div class="line"># group: root</div><div class="line">user::rwx</div><div class="line">group::---</div><div class="line">other::---</div></pre></td></tr></table></figure></p>
<p>运行 squid的用户是 proxy，由于设置了 acl，proxy用户访问不了/root内的文件（就算/root/config文件夹和 /root/config/pass 权限设置成777也没用！），所以就导致了squid没有权限去认证了。</p>
<p>ACL使得Linux可以进行更加复杂的权限控制，详细可以参见<a href="https://www.ibm.com/developerworks/cn/linux/l-acl/" target="_blank" rel="external">Linux ACL 体验</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://messyidea.com/2017/01/29/Linux-的-ACL/" data-id="cj4mh0s93000373517repn8bi" class="article-share-link" data-share="baidu" data-title="Linux 的 ACL">分享到</a>
      

      
        <a href="http://messyidea.com/2017/01/29/Linux-的-ACL/#disqus_thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-Opengrok-优秀的代码阅读工具" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/20/Opengrok-优秀的代码阅读工具/" class="article-date">
  <time datetime="2016-08-20T15:07:00.000Z" itemprop="datePublished">8月 20 2016</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Notes/">Notes</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/20/Opengrok-优秀的代码阅读工具/">Opengrok 优秀的代码阅读工具</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>linux下面阅读代码的工具比较少，一般都是IDE，vim + ctags 也不错，不过用着总有些不顺手。<br>搜了一下，发现还有woboq, LXR(Linux Cross Reference), opengrok 这类网页端的，LXR搭建起来比较麻烦，所以尝试了一下opengrok，感觉不错，这里记录一下搭建的流程(凭着记忆来的，可能会稍微有点问题)。</p>
<h2 id="安装JAVA"><a href="#安装JAVA" class="headerlink" title="安装JAVA"></a>安装JAVA</h2><p>首先安装java，先去<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">官网</a>下载jdk，一般解压打<code>/usr/java</code> 就可以了, 然后添加相应的环境变量(自己修改相应的path).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export JAVA_HOME=/usr/java/jdk1.8.0_73  </div><div class="line">export CLASSPATH=.:%JAVA_HOME%/lib/dt.jar:%JAVA_HOME%/lib/tools.jar  </div><div class="line">export PATH=$PATH:$JAVA_HOME/bin</div></pre></td></tr></table></figure></p>
<h2 id="安装tomcat"><a href="#安装tomcat" class="headerlink" title="安装tomcat"></a>安装tomcat</h2><p>之后去<a href="http://tomcat.apache.org/" target="_blank" rel="external">tomcat官网</a>下载tomcat, 并解压。我解压到了<code>/usr/local</code>里面，启动和关闭tomcat很简单，<code>path/to/tomcat/bin</code>下有启动和关闭的脚本(根据名字分辨，一个叫startup.sh, 另一个是 shutdown.sh)。</p>
<p>访问<code>ip:8080</code>,如果出现tomcat的界面就是安装成功了。</p>
<h2 id="安装opengrok"><a href="#安装opengrok" class="headerlink" title="安装opengrok"></a>安装opengrok</h2><p>去opengrok观望下载它的安装包，同样只是一个压缩包，随便解压到一个地方就可以了。比如<code>/usr/opengrok</code>。<br>压缩包里面有个source.war，在<code>/usr/opengrok/lib</code>下面，直接扔到<code>path/to/tomcat/webapps</code>目录下就可以了，之后访问<code>ip:8080/source</code> 就是opengrok的默认页面。</p>
<p>那怎么对代码进行索引等操作呢？<br>opengrok默认源代码处理的位置是在<code>/var/opengrok/src</code>里面(当然也可以改变位置，具体详见参数)，创建<code>/var/opengrok/src</code>一系列的目录，把你的源代码解压到里面，安装好ctags，然后在<code>path/to/opengrok/bin</code>目录运行<code>./Opengrok index</code>,等一段时间，数据就处理好了。<br>之后添加一个环境变量，<code>OPENGROK_TOMCAT_BASE</code>，变量内容是你的tomcat文件夹的位置，然后运行<code>./Opengrok deploy</code>, 重启tomcat，再次访问<code>ip:8080/source</code> 就可以看到已经处理好的代码了。</p>
<p>默认opengrok的背景是白色的，感觉比较伤眼睛，对此可以在浏览器安装一个夜间模式的插件，也可以到<code>/usr/local/tomcat/webapps/source/default</code>目录下修改<code>style.css</code>这个文件，把<code>body-&gt;background-color</code>的值改为浅绿色即可，<code>#B9DABD</code>。</p>
<p>如果是重要代码，可以按照<a href="http://fangpeishi.com/deploy_opengrok_and_implement_ldap_authentication.html" target="_blank" rel="external">这里</a>给opengrok加上LDAP验证，也可以让tomcat监听<code>127.0.0.1</code>，然后用nginx反代，在nginx上加上basic-auth即可。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://messyidea.com/2016/08/20/Opengrok-优秀的代码阅读工具/" data-id="cj4mh0s9h00057351x4edieuq" class="article-share-link" data-share="baidu" data-title="Opengrok 优秀的代码阅读工具">分享到</a>
      

      
        <a href="http://messyidea.com/2016/08/20/Opengrok-优秀的代码阅读工具/#disqus_thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Opengrok/">Opengrok</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tools/">tools</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-交叉编译树莓派的-aria2c" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/01/交叉编译树莓派的-aria2c/" class="article-date">
  <time datetime="2016-07-02T02:41:00.000Z" itemprop="datePublished">7月 1 2016</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Notes/">Notes</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/01/交叉编译树莓派的-aria2c/">交叉编译树莓派的 aria2c</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>aria2c 1.19.x 下载https链接始终有问题，所以最近想升级一下</p>
<p>惯例，下源码，编译，不过报错了。<code>expected type-specifier before string constant</code></p>
<p>看到<a href="https://github.com/aria2/aria2/issues/645" target="_blank" rel="external">这里</a>说是g++版本太低。自己懒，不太想折腾树莓派环境了，所以准备交叉编译一个。树莓派官方提供了交叉编译工具，所以很方便。</p>
<p>首先，随便创建一个文件夹，比如rpi<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd ~</div><div class="line">mkdir rpi</div><div class="line">cd rpi</div></pre></td></tr></table></figure></p>
<p>之后，git clone交叉编译工具<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone git://github.com/raspberrypi/tools.git</div></pre></td></tr></table></figure></p>
<p>clone 之后可以通过pull更新tools<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ~/rpi/tools</div><div class="line">git pull origin</div></pre></td></tr></table></figure></p>
<p>添加环境变量, 可以加在 .bashrc 中<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> for 32 bit</div><div class="line">export PATH=$PATH:$HOME/rpi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin</div><div class="line"><span class="meta">#</span> for 64 bit</div><div class="line">export PATH=$PATH:$HOME/rpi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin</div></pre></td></tr></table></figure></p>
<p>更新环境变量<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ~/.bashrc</div></pre></td></tr></table></figure></p>
<p>这样交叉编译环境就配置完成了。之后编译aria2c</p>
<p>首先下载最新的release源码，这里下载的是1.24版本的，然后解压<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget https://github.com/aria2/aria2/releases/download/release-1.24.0/aria2-1.24.0.tar.gz</div><div class="line">tar zxvf aria2-1.24.0.tar.gz</div><div class="line">cd aria2-1.24.0</div></pre></td></tr></table></figure></p>
<p>之后进行configure，貌似libxml2有点问题（见<a href="https://github.com/aria2/aria2/issues/627" target="_blank" rel="external">这里</a>），所以要加上<code>--without-libxml2</code>选项用Expat代替libxml2, host指编译之后是要运行在树莓派上的。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure --host=arm-linux-gnueabihf --without-libxml2</div></pre></td></tr></table></figure></p>
<p>如果想要静态链接，则执行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure --host=arm-linux-gnueabihf --without-libxml2 ARIA2_STATIC=yes</div></pre></td></tr></table></figure></p>
<p>configure之后<code>make</code>就可以了, 编译好的文件放在<code>src/aria2c</code>里。有点大（64mb），下载后放到树莓派中可以<code>strip</code>一下去除符号表以减少程序体积(缩小到了2.4mb)。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">strip -s aria2c</div></pre></td></tr></table></figure></p>
<p>之后就可以愉快地运行了。</p>
<p>aria2c的配置可以见<a href="https://blog.messyidea.com/archives/13/" target="_blank" rel="external">这里</a></p>
<h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><p>发现树莓派的交叉编译链没有openssl，所以还需要自己找源码编译<br>具体过程可以见<a href="https://github.com/lancethepants/aria2-arm-musl-static/blob/master/aria2.sh" target="_blank" rel="external">这个脚本</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://messyidea.com/2016/07/01/交叉编译树莓派的-aria2c/" data-id="cj4mh0s9t000a7351vqwgif03" class="article-share-link" data-share="baidu" data-title="交叉编译树莓派的 aria2c">分享到</a>
      

      
        <a href="http://messyidea.com/2016/07/01/交叉编译树莓派的-aria2c/#disqus_thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/aria2c/">aria2c</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/交叉编译/">交叉编译</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/树莓派/">树莓派</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-gogs配置" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/01/gogs配置/" class="article-date">
  <time datetime="2016-07-02T02:26:00.000Z" itemprop="datePublished">7月 1 2016</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Notes/">Notes</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/01/gogs配置/">给 gogs 加上 let&#39;s entrypt 证书</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>想给自己的gogs加个证书，现在 let’s entrypt 这么流行，而且免费，所以就用它了！</p>
<p>搜了一下发现可以又很多工具可以很方便地生成证书，搜了一下，选中了<a href="https://github.com/Neilpang/acme.sh" target="_blank" rel="external">acme.sh</a></p>
<h2 id="步骤如下："><a href="#步骤如下：" class="headerlink" title="步骤如下："></a>步骤如下：</h2><p>首先，git clone 获取脚本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/Neilpang/acme.sh.git</div></pre></td></tr></table></figure></p>
<p>let‘s entrypt 需要验证域名所有权，有好几种方式，有验证文件的，也有验证dns的。<br>gogs验证文件不太方便，所以使用验证dns的方法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">acme.sh --issue --dns -d  yourdomain.com</div></pre></td></tr></table></figure>
<p>之后它会提示让你设置一下子域名的txt记录，设置好之后，运行下面的命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">acme.sh --renew -d yourdomain.com</div></pre></td></tr></table></figure></p>
<p>之后它就会自动生成证书，告诉你放在什么地方。</p>
<p>那么nginx怎么使用呢？<br>首先，生成ssl_certificate<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 文件路径已省略，需要自己补上</div><div class="line">cat yourdomain.com.key fullchain.cer &gt; fullchain.pem</div></pre></td></tr></table></figure></p>
<p>之后在nginx的配置文件中加上以上配置就可以了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ssl_certificate     path/to/fullcain.pem;</div><div class="line">ssl_certificate_key  path/to/yourdomain.com.key;</div></pre></td></tr></table></figure></p>
<p>nginx虚拟主机配置文件如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">upstream gogs &#123;</div><div class="line">    server 127.0.0.1:3000 weight=1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;  </div><div class="line">    listen 443;</div><div class="line">    server_name yourdomain.com;</div><div class="line"></div><div class="line">    ssl on;</div><div class="line">    ssl_certificate path/to/fullcain.pem;</div><div class="line">    ssl_certificate_key path/to/yourdomain.com.key;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        proxy_set_header   X-Real-IP $remote_addr;</div><div class="line">        proxy_set_header   Host      $http_host;</div><div class="line">        proxy_pass         http://gogs;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果需要强制https可以见<a href="http://www.cnblogs.com/yun007/p/3739182.html" target="_blank" rel="external">这里</a><br>当然也可以启用HSTS, 见<a href="http://www.ttlsa.com/web/hsts-for-nginx-apache-lighttpd/" target="_blank" rel="external">这里</a> 和 <a href="https://linux.cn/article-5266-1.html" target="_blank" rel="external">这里</a></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>gogs 本身有配置证书的地方，但是如果要通过 nginx 访问 gogs的话，证书是需要在nginx配置的，gogs不需要配置。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://messyidea.com/2016/07/01/gogs配置/" data-id="cj4mh0s9o00087351mu3q7t0j" class="article-share-link" data-share="baidu" data-title="给 gogs 加上 let&#39;s entrypt 证书">分享到</a>
      

      
        <a href="http://messyidea.com/2016/07/01/gogs配置/#disqus_thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gogs/">gogs</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/let-s-entrypt/">let's entrypt</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ssl/">ssl</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Notes/ngrok-notes" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/24/Notes/ngrok-notes/" class="article-date">
  <time datetime="2016-05-24T23:23:30.000Z" itemprop="datePublished">5月 24 2016</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Notes/">Notes</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/24/Notes/ngrok-notes/">ngrok 源码解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ngrok是一个内网穿透工具，主要用途是让用户能够通过一台ngrok的中转服务器访问在内网中的一台机器。</p>
<p>用途有点类似与端口映射，要把一台内网中的机器的端口映射到具有公网ip的另一台机器的端口。</p>
<p>假如被映射的机器不在内网，那么可以直接通过映射的机器向被映射的机器创建链接转发来达到目的，但是如果被映射的机器在一个内网的话，就要复杂很多了。</p>
<p>首先需要内网的机器和外网的机器维护一条链接（因为外网的机器不能够主动连接内网的机器），为了避免链接的中断，需要通过心跳等途径维持链接。这条链接保证了外网机器能够随时和内网通信。</p>
<p>当然，单单一条链接是不够的，一般我们访问一个网页都会打开5-10个tcp链接，如果这些链接都阻塞在同一条链接上的话，性能会受很大的影响。<br>为了保证性能，外网机器和内网的机器可以制定一种协议，外网的机器可以通过协议请求内网的机器创建多条联通外网机器的链接以供传输。这样就可以保证请求可以被并行地响应，以保证性能。ngrok就是这么做的。</p>
<p>下面来看一下ngrok的执行流程（主要讲一下tcp的映射，省略了http,https和认证过程）。</p>
<p>ngrok主要分为ngrok和ngrokd，ngrok是客户端，ngrokd是服务端。</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>ngrokd启动的时候会执行一个tunnelListener函数，用来监听客户端的链接。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//server main.go</span></div><div class="line">tunnelListener(opts.tunnelAddr, tlsConfig)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">tunnelListener</span><span class="params">(addr <span class="keyword">string</span>, tlsConfig *tls.Config)</span></span> &#123;</div><div class="line">	<span class="comment">// listen for incoming connections</span></div><div class="line">	listener, err := conn.Listen(addr, <span class="string">"tun"</span>, tlsConfig)</div><div class="line">	<span class="comment">//...</span></div><div class="line">	log.Info(<span class="string">"Listening for control and proxy connections on %s"</span>, listener.Addr.String())</div><div class="line">	</div><div class="line">	<span class="keyword">for</span> c := <span class="keyword">range</span> listener.Conns &#123;</div><div class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(tunnelConn conn.Conn)</span></span> &#123;</div><div class="line">			</div><div class="line">			<span class="keyword">var</span> rawMsg msg.Message</div><div class="line">			<span class="keyword">if</span> rawMsg, err = msg.ReadMsg(tunnelConn); err != <span class="literal">nil</span> &#123;</div><div class="line">				tunnelConn.Warn(<span class="string">"Failed to read message: %v"</span>, err)</div><div class="line">				tunnelConn.Close()</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="keyword">switch</span> m := rawMsg.(<span class="keyword">type</span>) &#123;</div><div class="line">			<span class="keyword">case</span> *msg.Auth:</div><div class="line">				NewControl(tunnelConn, m)</div><div class="line"></div><div class="line">			<span class="keyword">case</span> *msg.RegProxy:</div><div class="line">				NewProxy(tunnelConn, m)</div><div class="line"></div><div class="line">			<span class="keyword">default</span>:</div><div class="line">				tunnelConn.Close()</div><div class="line">			&#125;</div><div class="line">		&#125;(c)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>中间有部分不需要的东西被删了。tunnelListener用来监听客户端。当有客户端连接的时候，它会先接收一个rawMsg（既定的协议），如果rawMsg是Auth类型的，那么就代表有新的客户端要连接了，那么就通过NewControl创建了一Control。</p>
<p>这个Control是一条进行控制的链接，是需要一直维护的。所有的控制信息都是通过这条链接来传递的。Control结构如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Control <span class="keyword">struct</span> &#123;</div><div class="line">	<span class="comment">// auth message</span></div><div class="line">	auth *msg.Auth</div><div class="line"></div><div class="line">	<span class="comment">// actual connection</span></div><div class="line">	conn conn.Conn</div><div class="line"></div><div class="line">	<span class="comment">// put a message in this channel to send it over</span></div><div class="line">	<span class="comment">// conn to the client</span></div><div class="line">	out <span class="keyword">chan</span> (msg.Message)</div><div class="line"></div><div class="line">	<span class="comment">// read from this channel to get the next message sent</span></div><div class="line">	<span class="comment">// to us over conn by the client</span></div><div class="line">	in <span class="keyword">chan</span> (msg.Message)</div><div class="line"></div><div class="line">	<span class="comment">// the last time we received a ping from the client - for heartbeats</span></div><div class="line">	lastPing time.Time</div><div class="line"></div><div class="line">	<span class="comment">// all of the tunnels this control connection handles</span></div><div class="line">	tunnels []*Tunnel</div><div class="line"></div><div class="line">	<span class="comment">// proxy connections</span></div><div class="line">	proxies <span class="keyword">chan</span> conn.Conn</div><div class="line"></div><div class="line">	<span class="comment">// identifier</span></div><div class="line">	id <span class="keyword">string</span></div><div class="line"></div><div class="line">	<span class="comment">// synchronizer for controlled shutdown of writer()</span></div><div class="line">	writerShutdown *util.Shutdown</div><div class="line"></div><div class="line">	<span class="comment">// synchronizer for controlled shutdown of reader()</span></div><div class="line">	readerShutdown *util.Shutdown</div><div class="line"></div><div class="line">	<span class="comment">// synchronizer for controlled shutdown of manager()</span></div><div class="line">	managerShutdown *util.Shutdown</div><div class="line"></div><div class="line">	<span class="comment">// synchronizer for controller shutdown of entire Control</span></div><div class="line">	shutdown *util.Shutdown</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，auth是认证信息，ctlConn指的就是控制链接本身。out和in控制着数据的读入和读出，所有加入out的msg都会被发送到对应的客户端，所有ctlConn接收到的msg都会被放入in。分别由reader和writer这两个goroutine实现。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">writer</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// write messages to the control channel</span></div><div class="line">	<span class="keyword">for</span> m := <span class="keyword">range</span> c.out &#123;</div><div class="line">		c.conn.SetWriteDeadline(time.Now().Add(controlWriteTimeout))</div><div class="line">		<span class="keyword">if</span> err := msg.WriteMsg(c.conn, m); err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="built_in">panic</span>(err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">reader</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// read messages from the control channel</span></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">if</span> msg, err := msg.ReadMsg(c.conn); err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">if</span> err == io.EOF &#123;</div><div class="line">				c.conn.Info(<span class="string">"EOF"</span>)</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				<span class="built_in">panic</span>(err)</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">// this can also panic during shutdown</span></div><div class="line">			c.in &lt;- msg</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有两个重要的元素是proxies和tunnel。tunnel存放的是外网机器监听外部连接的链接，proxies存放的是外网机器访问内网的链接。</p>
<p>Control建立之后会随机生成一个id，这个id代表着对应的client的id。生成id之后Control会把这个id相关的信息发送给客户端，之后这个id就代表着客户端了。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">c.out &lt;- &amp;msg.AuthResp&#123;</div><div class="line">		Version:   version.Proto,</div><div class="line">		MmVersion: version.MajorMinor(),</div><div class="line">		ClientId:  c.id,</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>客户端接受到这个id信息之后，会在以后的消息中带上这个id，方便服务端确认是哪个客户端。<br>为了方便服务端通过id找到对应的Control，服务端会把id和对应Control放在一个map里面，这个map就是controlRegistry。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">controlRegistry.Add(c.id, c);</div></pre></td></tr></table></figure>
<p>之后，Control会监听从客户端发来的请求（这个时候服务端还没建立端口映射，需要客户端发相应的请求：我要吧自己的什么端口映射到服务端的什么端口上）<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">manager</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> mRaw, ok := &lt;-c.in:</div><div class="line">			<span class="comment">// c.in closes to indicate shutdown</span></div><div class="line">			<span class="keyword">if</span> !ok &#123;</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="keyword">switch</span> m := mRaw.(<span class="keyword">type</span>) &#123;</div><div class="line">			<span class="keyword">case</span> *msg.ReqTunnel:</div><div class="line">				c.registerTunnel(m)</div><div class="line"></div><div class="line">			<span class="keyword">case</span> *msg.Ping:</div><div class="line">				c.lastPing = time.Now()</div><div class="line">				c.out &lt;- &amp;msg.Pong&#123;&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，msg.Ping是心跳信息，msg.ReqTunnel是客户端请求映射的信息。服务端接收到客户端请求，会创建一个新的tunnel</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Register a new tunnel on this control connection</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">registerTunnel</span><span class="params">(rawTunnelReq *msg.ReqTunnel)</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> _, proto := <span class="keyword">range</span> strings.Split(rawTunnelReq.Protocol, <span class="string">"+"</span>) &#123;</div><div class="line">		tunnelReq := *rawTunnelReq</div><div class="line">		tunnelReq.Protocol = proto</div><div class="line"></div><div class="line">		c.conn.Debug(<span class="string">"Registering new tunnel"</span>)</div><div class="line">		t, err := NewTunnel(&amp;tunnelReq, c)</div><div class="line"></div><div class="line">		<span class="comment">// add it to the list of tunnels</span></div><div class="line">		c.tunnels = <span class="built_in">append</span>(c.tunnels, t)</div><div class="line"></div><div class="line">		<span class="comment">// acknowledge success</span></div><div class="line">		c.out &lt;- &amp;msg.NewTunnel&#123;</div><div class="line">			Url:      t.url,</div><div class="line">			Protocol: proto,</div><div class="line">			ReqId:    rawTunnelReq.ReqId,</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		rawTunnelReq.Hostname = strings.Replace(t.url, proto+<span class="string">"://"</span>, <span class="string">""</span>, <span class="number">1</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//创建tunnel</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTunnel</span><span class="params">(m *msg.ReqTunnel, ctl *Control)</span> <span class="params">(t *Tunnel, err error)</span></span> &#123;</div><div class="line">	t = &amp;Tunnel&#123;</div><div class="line">		req:    m,</div><div class="line">		start:  time.Now(),</div><div class="line">		ctl:    ctl,</div><div class="line">		Logger: log.NewPrefixLogger(),</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	proto := t.req.Protocol</div><div class="line">	<span class="keyword">switch</span> proto &#123;</div><div class="line">	<span class="keyword">case</span> <span class="string">"tcp"</span>:</div><div class="line">		bindTcp := <span class="function"><span class="keyword">func</span><span class="params">(port <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">			<span class="keyword">if</span> t.listener, err = net.ListenTCP(<span class="string">"tcp"</span>, &amp;net.TCPAddr&#123;IP: net.ParseIP(<span class="string">"0.0.0.0"</span>), Port: port&#125;); err != <span class="literal">nil</span> &#123;</div><div class="line">				err = t.ctl.conn.Error(<span class="string">"Error binding TCP listener: %v"</span>, err)</div><div class="line">				<span class="keyword">return</span> err</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">// create the url</span></div><div class="line">			addr := t.listener.Addr().(*net.TCPAddr)</div><div class="line">			t.url = fmt.Sprintf(<span class="string">"tcp://%s:%d"</span>, opts.domain, addr.Port)</div><div class="line"></div><div class="line">			<span class="comment">// register it</span></div><div class="line">			<span class="keyword">if</span> err = tunnelRegistry.RegisterAndCache(t.url, t); err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="comment">// This should never be possible because the OS will</span></div><div class="line">				<span class="comment">// only assign available ports to us.</span></div><div class="line">				t.listener.Close()</div><div class="line">				err = fmt.Errorf(<span class="string">"TCP listener bound, but failed to register %s"</span>, t.url)</div><div class="line">				<span class="keyword">return</span> err</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="keyword">go</span> t.listenTcp(t.listener)</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		</div><div class="line">		</div><div class="line"><span class="comment">// Listens for new public tcp connections from the internet.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tunnel)</span> <span class="title">listenTcp</span><span class="params">(listener *net.TCPListener)</span></span> &#123;</div><div class="line">		<span class="comment">// accept public connections</span></div><div class="line">		tcpConn, err := listener.AcceptTCP()</div><div class="line"></div><div class="line">		conn := conn.Wrap(tcpConn, <span class="string">"pub"</span>)</div><div class="line">		conn.AddLogPrefix(t.Id())</div><div class="line">		conn.Info(<span class="string">"New connection from %v"</span>, conn.RemoteAddr())</div><div class="line"></div><div class="line">		<span class="keyword">go</span> t.HandlePublicConnection(conn)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Control建立一个tunnel之后会发送一个msg.NewTunnel信息给客户端，代表tunnel已经建立。这个tunnel会被放在Control的tunnels结构中去。新建Tunnel的过程中，会把url和tunnel的信息注册到一个map中，方便通过url获取到对应的tunnle，这个map是tunnelRegistry。</p>
<p>tunnel建立之后，基本的工作都已经做完了，只需要在tunnel里面监听外网的链接就行了。下面来看一下对外网链接的处理。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tunnel)</span> <span class="title">HandlePublicConnection</span><span class="params">(publicConn conn.Conn)</span></span> &#123;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> proxyConn conn.Conn</div><div class="line">	<span class="keyword">var</span> err error</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; (<span class="number">2</span> * proxyMaxPoolSize); i++ &#123;</div><div class="line">		<span class="comment">// get a proxy connection</span></div><div class="line">		<span class="keyword">if</span> proxyConn, err = t.ctl.GetProxy(); err != <span class="literal">nil</span> &#123;</div><div class="line">			t.Warn(<span class="string">"Failed to get proxy connection: %v"</span>, err)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// tell the client we're going to start using this proxy connection</span></div><div class="line">		startPxyMsg := &amp;msg.StartProxy&#123;</div><div class="line">			Url:        t.url,</div><div class="line">			ClientAddr: publicConn.RemoteAddr().String(),</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> err = msg.WriteMsg(proxyConn, startPxyMsg); err != <span class="literal">nil</span> &#123;</div><div class="line">			proxyConn.Warn(<span class="string">"Failed to write StartProxyMessage: %v, attempt %d"</span>, err, i)</div><div class="line">			proxyConn.Close()</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">// success</span></div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// join the public and proxy connections</span></div><div class="line">	bytesIn, bytesOut := conn.Join(publicConn, proxyConn)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为现在服务端和客户端只有一条链接（Control），这条链接主要是传送相关的控制消息，为了传输数据，请求客户端创建proxy链接。这个操作在 t.ctl.GetProxy()中完成。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">GetProxy</span><span class="params">()</span> <span class="params">(proxyConn conn.Conn, err error)</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> ok <span class="keyword">bool</span></div><div class="line"></div><div class="line">	<span class="comment">// get a proxy connection from the pool</span></div><div class="line">	<span class="keyword">select</span> &#123;</div><div class="line">	<span class="keyword">case</span> proxyConn, ok = &lt;-c.proxies:</div><div class="line">		<span class="keyword">if</span> !ok &#123;</div><div class="line">			err = fmt.Errorf(<span class="string">"No proxy connections available, control is closing"</span>)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="comment">// no proxy available in the pool, ask for one over the control channel</span></div><div class="line">		c.conn.Debug(<span class="string">"No proxy in pool, requesting proxy from control . . ."</span>)</div><div class="line">		<span class="keyword">if</span> err = util.PanicToError(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.out &lt;- &amp;msg.ReqProxy&#123;&#125; &#125;); err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> proxyConn, ok = &lt;-c.proxies:</div><div class="line">			<span class="keyword">if</span> !ok &#123;</div><div class="line">				err = fmt.Errorf(<span class="string">"No proxy connections available, control is closing"</span>)</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line"></div><div class="line">		<span class="keyword">case</span> &lt;-time.After(pingTimeoutInterval):</div><div class="line">			err = fmt.Errorf(<span class="string">"Timeout trying to get proxy connection"</span>)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getproxy函数会首先在Control的proxies中找有没有已存在的链接，如果有的话直接拿出来用，如果没有的话请求客户端创建proxy链接，并阻塞在select。客户端会连接服务端，并发送注册proxy的消息msg.RegProxy。这个消息中会带有客户端的id。<br>服务端通过这个id把这条链接存放在c.proxies中，这样的话GetProxy继续运行，并返回可用的proxy链接。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//接收新的proxy链接消息</span></div><div class="line">	<span class="keyword">switch</span> m := rawMsg.(<span class="keyword">type</span>) &#123;</div><div class="line">			<span class="keyword">case</span> *msg.Auth:</div><div class="line">				NewControl(tunnelConn, m)</div><div class="line"></div><div class="line">			<span class="keyword">case</span> *msg.RegProxy:</div><div class="line">				NewProxy(tunnelConn, m)</div><div class="line"></div><div class="line">			<span class="keyword">default</span>:</div><div class="line">				tunnelConn.Close()</div><div class="line">			&#125;</div><div class="line">			</div><div class="line"><span class="comment">//根据id找到control，把链接放入proxies</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProxy</span><span class="params">(pxyConn conn.Conn, regPxy *msg.RegProxy)</span></span> &#123;</div><div class="line">	ctl := controlRegistry.Get(regPxy.ClientId)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> ctl == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"No client found for identifier: "</span> + regPxy.ClientId)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	ctl.RegisterProxy(pxyConn)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>获取proxy链接之后只要把tunnel和proxy链接相连就可以实现数据传输了<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// join the public and proxy connections</span></div><div class="line">bytesIn, bytesOut := conn.Join(publicConn, proxyConn)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(c Conn, c2 Conn)</span> <span class="params">(<span class="keyword">int64</span>, <span class="keyword">int64</span>)</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> wait sync.WaitGroup</div><div class="line"></div><div class="line">	pipe := <span class="function"><span class="keyword">func</span><span class="params">(to Conn, from Conn, bytesCopied *<span class="keyword">int64</span>)</span></span> &#123;</div><div class="line">		<span class="keyword">defer</span> to.Close()</div><div class="line">		<span class="keyword">defer</span> from.Close()</div><div class="line">		<span class="keyword">defer</span> wait.Done()</div><div class="line"></div><div class="line">		<span class="keyword">var</span> err error</div><div class="line">		*bytesCopied, err = io.Copy(to, from)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			from.Warn(<span class="string">"Copied %d bytes to %s before failing with error %v"</span>, *bytesCopied, to.Id(), err)</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			from.Debug(<span class="string">"Copied %d bytes to %s"</span>, *bytesCopied, to.Id())</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	wait.Add(<span class="number">2</span>)</div><div class="line">	<span class="keyword">var</span> fromBytes, toBytes <span class="keyword">int64</span></div><div class="line">	<span class="keyword">go</span> pipe(c, c2, &amp;fromBytes)</div><div class="line">	<span class="keyword">go</span> pipe(c2, c, &amp;toBytes)</div><div class="line">	c.Info(<span class="string">"Joined with connection %s"</span>, c2.Id())</div><div class="line">	wait.Wait()</div><div class="line">	<span class="keyword">return</span> fromBytes, toBytes</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>客户端的部分行为在上文中已经提及了，这里简单讲一下。</p>
<p>读取配置文件之后，客户端会创建一个Controller运行。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NewController().Run(config)</div></pre></td></tr></table></figure></p>
<p>Controller有一个web端，主要显示一些连接的信息（只有http和https会显示，tcp协议不会），这个部分不说了，主要说一下和服务端通信的部分。<br>Controller中会执行model.run运行clientmodel。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ctl.Go(ctl.model.Run)</div></pre></td></tr></table></figure></p>
<p>clientmodel会执行control函数<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ClientModel)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// how long we should wait before we reconnect</span></div><div class="line">	maxWait := <span class="number">30</span> * time.Second</div><div class="line">	wait := <span class="number">1</span> * time.Second</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="comment">// run the control channel</span></div><div class="line">		c.control()</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在control函数中，client会根据配置文件连接到相应的服务端进行认证，成功之后发送要进行映射的tunnel信息。发送成功之后就等着听取服务端的命令就好了。（同时要自己维护心跳）<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Establishes and manages a tunnel control connection with the server</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ClientModel)</span> <span class="title">control</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">	<span class="comment">// establish control channel</span></div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		ctlConn conn.Conn</div><div class="line">		err     error</div><div class="line">	)</div><div class="line">	<span class="keyword">if</span> c.proxyUrl == <span class="string">""</span> &#123;</div><div class="line">		<span class="comment">// simple non-proxied case, just connect to the server</span></div><div class="line">		ctlConn, err = conn.Dial(c.serverAddr, <span class="string">"ctl"</span>, c.tlsConfig)</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		ctlConn, err = conn.DialHttpProxy(c.proxyUrl, c.serverAddr, <span class="string">"ctl"</span>, c.tlsConfig)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// authenticate with the server</span></div><div class="line">	auth := &amp;msg.Auth&#123;</div><div class="line">		ClientId:  c.id,</div><div class="line">		OS:        runtime.GOOS,</div><div class="line">		Arch:      runtime.GOARCH,</div><div class="line">		Version:   version.Proto,</div><div class="line">		MmVersion: version.MajorMinor(),</div><div class="line">		User:      c.authToken,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err = msg.WriteMsg(ctlConn, auth); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// wait for the server to authenticate us</span></div><div class="line">	<span class="keyword">var</span> authResp msg.AuthResp</div><div class="line">	<span class="keyword">if</span> err = msg.ReadMsgInto(ctlConn, &amp;authResp); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	c.id = authResp.ClientId</div><div class="line">	c.serverVersion = authResp.MmVersion</div><div class="line">	c.Info(<span class="string">"Authenticated with server, client id: %v"</span>, c.id)</div><div class="line">	c.update()</div><div class="line">	<span class="keyword">if</span> err = SaveAuthToken(c.configPath, c.authToken); err != <span class="literal">nil</span> &#123;</div><div class="line">		c.Error(<span class="string">"Failed to save auth token: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// request tunnels</span></div><div class="line">	reqIdToTunnelConfig := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*TunnelConfiguration)</div><div class="line">	<span class="keyword">for</span> _, config := <span class="keyword">range</span> c.tunnelConfig &#123;</div><div class="line">		<span class="comment">// create the protocol list to ask for</span></div><div class="line">		<span class="keyword">var</span> protocols []<span class="keyword">string</span></div><div class="line">		<span class="keyword">for</span> proto, _ := <span class="keyword">range</span> config.Protocols &#123;</div><div class="line">			protocols = <span class="built_in">append</span>(protocols, proto)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		reqTunnel := &amp;msg.ReqTunnel&#123;</div><div class="line">			ReqId:      util.RandId(<span class="number">8</span>),</div><div class="line">			Protocol:   strings.Join(protocols, <span class="string">"+"</span>),</div><div class="line">			Hostname:   config.Hostname,</div><div class="line">			Subdomain:  config.Subdomain,</div><div class="line">			HttpAuth:   config.HttpAuth,</div><div class="line">			RemotePort: config.RemotePort,</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// send the tunnel request</span></div><div class="line">		<span class="keyword">if</span> err = msg.WriteMsg(ctlConn, reqTunnel); err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="built_in">panic</span>(err)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// save request id association so we know which local address</span></div><div class="line">		<span class="comment">// to proxy to later</span></div><div class="line">		reqIdToTunnelConfig[reqTunnel.ReqId] = config</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// start the heartbeat</span></div><div class="line">	lastPong := time.Now().UnixNano()</div><div class="line">	c.ctl.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.heartbeat(&amp;lastPong, ctlConn) &#125;)</div><div class="line"></div><div class="line">	<span class="comment">// main control loop</span></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">var</span> rawMsg msg.Message</div><div class="line">		<span class="keyword">if</span> rawMsg, err = msg.ReadMsg(ctlConn); err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="built_in">panic</span>(err)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">switch</span> m := rawMsg.(<span class="keyword">type</span>) &#123;</div><div class="line">		<span class="keyword">case</span> *msg.ReqProxy:</div><div class="line">			c.ctl.Go(c.proxy)</div><div class="line"></div><div class="line">		<span class="keyword">case</span> *msg.Pong:</div><div class="line">			atomic.StoreInt64(&amp;lastPong, time.Now().UnixNano())</div><div class="line"></div><div class="line">		<span class="keyword">case</span> *msg.NewTunnel:</div><div class="line">			<span class="keyword">if</span> m.Error != <span class="string">""</span> &#123;</div><div class="line">				emsg := fmt.Sprintf(<span class="string">"Server failed to allocate tunnel: %s"</span>, m.Error)</div><div class="line">				c.Error(emsg)</div><div class="line">				c.ctl.Shutdown(emsg)</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line"></div><div class="line">			tunnel := mvc.Tunnel&#123;</div><div class="line">				PublicUrl: m.Url,</div><div class="line">				LocalAddr: reqIdToTunnelConfig[m.ReqId].Protocols[m.Protocol],</div><div class="line">				Protocol:  c.protoMap[m.Protocol],</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			c.tunnels[tunnel.PublicUrl] = tunnel</div><div class="line">			c.connStatus = mvc.ConnOnline</div><div class="line">			c.Info(<span class="string">"Tunnel established at %v"</span>, tunnel.PublicUrl)</div><div class="line">			c.update()</div><div class="line"></div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			ctlConn.Warn(<span class="string">"Ignoring unknown control message %v "</span>, m)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里最重要的信息是msg.ReqProxy，接受到这个信息之后服务端会主动创建客户端到服务端的proxy链接<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Establishes and manages a tunnel proxy connection with the server</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ClientModel)</span> <span class="title">proxy</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		remoteConn conn.Conn</div><div class="line">		err        error</div><div class="line">	)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> c.proxyUrl == <span class="string">""</span> &#123;</div><div class="line">		remoteConn, err = conn.Dial(c.serverAddr, <span class="string">"pxy"</span>, c.tlsConfig)</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		remoteConn, err = conn.DialHttpProxy(c.proxyUrl, c.serverAddr, <span class="string">"pxy"</span>, c.tlsConfig)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	err = msg.WriteMsg(remoteConn, &amp;msg.RegProxy&#123;ClientId: c.id&#125;)</div><div class="line"></div><div class="line">	<span class="comment">// wait for the server to ack our register</span></div><div class="line">	<span class="keyword">var</span> startPxy msg.StartProxy</div><div class="line">	<span class="keyword">if</span> err = msg.ReadMsgInto(remoteConn, &amp;startPxy); err != <span class="literal">nil</span> &#123;</div><div class="line">		remoteConn.Error(<span class="string">"Server failed to write StartProxy: %v"</span>, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	tunnel, ok := c.tunnels[startPxy.Url]</div><div class="line">	<span class="keyword">if</span> !ok &#123;</div><div class="line">		remoteConn.Error(<span class="string">"Couldn't find tunnel for proxy: %s"</span>, startPxy.Url)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// start up the private connection</span></div><div class="line">	start := time.Now()</div><div class="line">	localConn, err := conn.Dial(tunnel.LocalAddr, <span class="string">"prv"</span>, <span class="literal">nil</span>)</div><div class="line"></div><div class="line">	m := c.metrics</div><div class="line">	m.proxySetupTimer.Update(time.Since(start))</div><div class="line">	m.connMeter.Mark(<span class="number">1</span>)</div><div class="line">	c.update()</div><div class="line">	m.connTimer.Time(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		localConn := tunnel.Protocol.WrapConn(localConn, mvc.ConnectionContext&#123;Tunnel: tunnel, ClientAddr: startPxy.ClientAddr&#125;)</div><div class="line">		bytesIn, bytesOut := conn.Join(localConn, remoteConn)</div><div class="line">		m.bytesIn.Update(bytesIn)</div><div class="line">		m.bytesOut.Update(bytesOut)</div><div class="line">		m.bytesInCount.Inc(bytesIn)</div><div class="line">		m.bytesOutCount.Inc(bytesOut)</div><div class="line">	&#125;)</div><div class="line">	c.update()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上就是ngrok服务端和客户端的主要逻辑了。</p>
<p>写的比较匆忙，如果看不明白可以找相关的文章对比着看看。比如这篇：<a href="http://tonybai.com/2015/05/14/ngrok-source-intro/" target="_blank" rel="external">ngrok原理浅析</a> </p>
<p>如果想要搭建ngrok服务端，可以看这篇：<a href="https://imququ.com/post/self-hosted-ngrokd.html" target="_blank" rel="external">搭建 ngrok 服务实现内网穿透</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://messyidea.com/2016/05/24/Notes/ngrok-notes/" data-id="cj4mh0sdz00337351nh7c9cfe" class="article-share-link" data-share="baidu" data-title="ngrok 源码解析">分享到</a>
      

      
        <a href="http://messyidea.com/2016/05/24/Notes/ngrok-notes/#disqus_thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-Mess/rinetd-端口转发" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/09/Mess/rinetd-端口转发/" class="article-date">
  <time datetime="2015-10-09T23:06:41.000Z" itemprop="datePublished">10月 9 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Mess/">Mess</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/09/Mess/rinetd-端口转发/">rinetd端口转发</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>发现linux下面有一个很方便的端口转发和反向代理的工具rinetd</p>
<p>安装后配置文件默认放在etc的rinetd.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vim /etc/rinetd.conf</div><div class="line">0.0.0.0 8080 192.168.1.2 8080</div></pre></td></tr></table></figure>
<p>上述配置就是把访问将所有发往本机8080端口的请求转发到192.168.1.2的8080端口<br>修改好之后重启软件就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">关闭进程</div><div class="line">pkill rinetd</div><div class="line">启动软件</div><div class="line">rinetd -c /etc/rinetd.conf</div><div class="line">查看端口监听状态</div><div class="line">netstat -antup</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://messyidea.com/2015/10/09/Mess/rinetd-端口转发/" data-id="cj4mh0sd8002b7351en4xseqt" class="article-share-link" data-share="baidu" data-title="rinetd端口转发">分享到</a>
      

      
        <a href="http://messyidea.com/2015/10/09/Mess/rinetd-端口转发/#disqus_thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux C/sched-param" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/08/31/Linux C/sched-param/" class="article-date">
  <time datetime="2015-09-01T02:42:14.000Z" itemprop="datePublished">8月 31 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux-C/">Linux C</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/31/Linux C/sched-param/">sched_param</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#include &lt;sched.h&gt;</div><div class="line"></div><div class="line">struct sched_param &#123; </div><div class="line">    int32_t  sched_priority; </div><div class="line">    int32_t  sched_curpriority; </div><div class="line">    union &#123; </div><div class="line">        int32_t  reserved[8]; </div><div class="line">        struct &#123;    </div><div class="line">            int32_t  __ss_low_priority;  </div><div class="line">            int32_t  __ss_max_repl;  </div><div class="line">            struct timespec     __ss_repl_period;   </div><div class="line">            struct timespec     __ss_init_budget;   </div><div class="line">        &#125;           __ss;   </div><div class="line">    &#125;           __ss_un;    </div><div class="line">&#125;</div><div class="line"></div><div class="line">#define sched_ss_low_priority   __ss_un.__ss.__ss_low_priority</div><div class="line">#define sched_ss_max_repl       __ss_un.__ss.__ss_max_repl</div><div class="line">#define sched_ss_repl_period    __ss_un.__ss.__ss_repl_period</div><div class="line">#define sched_ss_init_budget    __ss_un.__ss.__ss_init_budget</div></pre></td></tr></table></figure>
<p>linux 内核有三种调度策略：</p>
<ol>
<li>SCHED_OTHER 分时</li>
<li>SCHED_FIFO 实时，先到先服务，一直运行到更高优先级到达或者时间片用完</li>
<li>SCHED_RR 时间片轮转。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//linux 可以通过下面的函数来获取线程最高和最低优先级</div><div class="line">int sched_get_priority_max(int policy);</div><div class="line">int sched_get_priority_min(int policy);</div><div class="line"></div><div class="line">//设置和获取优先级</div><div class="line">int pthread_attr_setschedparam(pthread_attr_t *attr, const struct sched_param *param);</div><div class="line">int pthread_attr_getschedparam(const pthread_attr_t *attr, struct sched_param *param);</div><div class="line"> param.sched_priority = 51; //设置优先级</div><div class="line"> </div><div class="line"> </div><div class="line"> //改变调度策略</div><div class="line"> int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy);</div><div class="line"> </div><div class="line"> //设置调度策略</div><div class="line">#include &lt;sched.h&gt;</div><div class="line">int sched_setscheduler(pid_t pid, int policy,</div><div class="line">const struct sched_param *param);</div><div class="line">/*</div><div class="line">sched_setscheduler()函数将pid所指定进程的调度策略和调度参数分别设置为param指向的sched_param结构中指定的policy和参数。sched_param结构中的sched_priority成员的值可以为任何整数，该整数位于policy所指定调度策略的优先级范围内(含边界值)。policy参数的可能值在头文件中定义。</div><div class="line">如果存在pid所描述的进程，将会为进程ID等于pid的进程设置调度策略和调度参数。</div><div class="line">如果pid为零，将会为调用进程设置调度策略和调度参数。</div><div class="line">如果进程pid含多个进程或轻量进程(即该进程是多进程的)，此函数将影响进程中各个子进程。</div><div class="line">更改其他进程的调度参数需要有相应的特权。调用进程必须具有相应的特权，或者是具有PRIV_RTSCHED权限的组的成员，才能成功调用sched_setscheduler()。如果sched_setscheduler()函数成功地将pid所指定调度策略和调度参数分别设置为policy和结构param指定值 ，则该函数调用成功。</div><div class="line">*/</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://messyidea.com/2015/08/31/Linux C/sched-param/" data-id="cj4mh0scn001n73518pvtsxx0" class="article-share-link" data-share="baidu" data-title="sched_param">分享到</a>
      

      
        <a href="http://messyidea.com/2015/08/31/Linux C/sched-param/#disqus_thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux C/gcc-attribute" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/08/31/Linux C/gcc-attribute/" class="article-date">
  <time datetime="2015-09-01T02:41:39.000Z" itemprop="datePublished">8月 31 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux-C/">Linux C</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/31/Linux C/gcc-attribute/">gcc attribute</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>attribute</strong>关键字主要是用来在函数或数据声明中设置其属性。给函数赋给属性的主要目的在于让编译器进行优化。函数声明中的<strong>attribute</strong>((noreturn))，就是告诉编译器这个函数不会返回给调用者，以便编译器在优化时去掉不必要的函数返回代码。<br>GNU C的一大特色就是<strong>attribute</strong>机制。<strong>attribute</strong>可以设置函数属性（Function Attribute）、变量属性（Variable Attribute）和类型属性（Type Attribute）。</p>
<p><strong>attribute</strong>书写特征是：<strong>attribute</strong>前后都有两个下划线，并且后面会紧跟一对括弧，括弧里面是相应的<strong>attribute</strong>参数。</p>
<p><strong>attribute</strong>语法格式为：</p>
<p><strong>attribute</strong> ((attribute-list))</p>
<p>其位置约束：放于声明的尾部“；”之前。</p>
<p>函数属性（Function Attribute）：函数属性可以帮助开发者把一些特性添加到函数声明中，从而可以使编译器在错误检查方面的功能更强大。<strong>attribute</strong>机制也很容易同非GNU应用程序做到兼容之功效。</p>
<p><a href="http://blog.sina.com.cn/s/blog_7e719f0501012tkt.html" target="_blank" rel="external">例子可参见这里</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://messyidea.com/2015/08/31/Linux C/gcc-attribute/" data-id="cj4mh0sck001h7351wxrrpre7" class="article-share-link" data-share="baidu" data-title="gcc attribute">分享到</a>
      

      
        <a href="http://messyidea.com/2015/08/31/Linux C/gcc-attribute/#disqus_thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-C/">Linux C</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mess/">Mess</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Notes/">Notes</a><span class="category-list-count">12</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Opengrok/">Opengrok</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/System/">System</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Warming/">Warming</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/aria2c/">aria2c</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gdb/">gdb</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gogs/">gogs</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/let-s-entrypt/">let's entrypt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/life-now/">life now</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssl/">ssl</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tools/">tools</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/交叉编译/">交叉编译</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树/">树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树莓派/">树莓派</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线段树/">线段树</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Opengrok/" style="font-size: 10px;">Opengrok</a> <a href="/tags/System/" style="font-size: 10px;">System</a> <a href="/tags/Warming/" style="font-size: 20px;">Warming</a> <a href="/tags/aria2c/" style="font-size: 10px;">aria2c</a> <a href="/tags/gdb/" style="font-size: 10px;">gdb</a> <a href="/tags/git/" style="font-size: 20px;">git</a> <a href="/tags/gogs/" style="font-size: 10px;">gogs</a> <a href="/tags/let-s-entrypt/" style="font-size: 10px;">let's entrypt</a> <a href="/tags/life-now/" style="font-size: 10px;">life now</a> <a href="/tags/ssl/" style="font-size: 10px;">ssl</a> <a href="/tags/tools/" style="font-size: 10px;">tools</a> <a href="/tags/交叉编译/" style="font-size: 10px;">交叉编译</a> <a href="/tags/树/" style="font-size: 10px;">树</a> <a href="/tags/树莓派/" style="font-size: 10px;">树莓派</a> <a href="/tags/线段树/" style="font-size: 10px;">线段树</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">六月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">五月 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">三月 2015</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">二月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">一月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">十二月 2014</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">十一月 2014</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/03/Hasee-Z7-sl7d3-archlinux-安装教程/">Hasee Z7 sl7d3 archlinux 安装笔记</a>
          </li>
        
          <li>
            <a href="/2017/02/17/git-repo-永久删除大文件/">git repo 永久删除大文件</a>
          </li>
        
          <li>
            <a href="/2017/01/29/Linux-的-ACL/">Linux 的 ACL</a>
          </li>
        
          <li>
            <a href="/2016/08/20/Opengrok-优秀的代码阅读工具/">Opengrok 优秀的代码阅读工具</a>
          </li>
        
          <li>
            <a href="/2016/07/01/交叉编译树莓派的-aria2c/">交叉编译树莓派的 aria2c</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 messyidea<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/Projects" class="mobile-nav-link">Projects</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<script>
  var disqus_shortname = 'messyidea';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/script.js"></script>

</div>
</body>
</html>
